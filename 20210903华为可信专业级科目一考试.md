# 题目一：销售套餐

节日活动，有销售套餐 `sales = [主产品编号, 成本, 利润]`，还有 `limit = [主产品编号, 个数]`，以及需要凑齐套餐的数量 `cnt`

> 输入：`sales` `limit` `cnt`
>
> 输出：长度为 `cnt` 的套餐编号数组，凑不到则输出 `-1`；
>
> ​            优先输出成本最低的，如果成本一样则输出利润最高的，如果还一样就输出编号小的

- 举例

```bash
# stdin:
sales = [[200, 10, 30],
         [100, 20, 20],
         [300, 20, 20],
         [200, 20, 30]]
         
limit = [[200, 1],
         [100, 1],
         [300, 1]]
         
cnt = 2

# stdout:
ans = [[200, 10, 30],[100, 20, 20]]

# 解析
1）挑出成本最低的`cnt=2`个，发现是[[200, 10, 30], [200, 20, 30]]
2）但是`limit`中，编号为`200`的主产品只能有一个，所以[200, 20, 30]不行
3）而[100, 20, 20]和[300, 20, 20]成本利润都一样，所以选编号小的`100`
4）最后结果是[[200, 10, 30],[100, 20, 20]]
```



# 题目二：座位预定

实现座位预定功能，座位预定的类中有：

- 初始化方法 `__init__(self, cabins: List[int])`，用于初始化舱位信息

  > `cabins`的下标即为舱号，其元素是座位数。例如：`cabins = [10, 1]`，那么就是 `0号舱有10个座位(0到9号座)` `1号舱有1个座位`

- 订单方法 `book(self, book_id: int, cabin_id: int, num: int) -> bool` ，用于订单

  > `book_id`是订单号，`cabin_id`是预定的舱号，`num`是预定的座位数量
  >
  > 若候补队列有订单，或者座位不足`num`，则将订单放入候补队列
  >
  > 优先预定连续座位，比如`0, 1, 4, 5`被定的情况下预定三个座位，则选`6, 7, 8`

- 取消方法`cancel(self, book_id: int) -> bool`，取消订单

  > 若在候补队列中则直接取消
  >
  > 已预定的订单则需更新座位信息

- 查询方法`query(self, book_id: int) -> int`，查询该订单中最小的的座位号

  > 查询不到则返回`-1`，比如无此订单号、订单已取消

- 此外，若候补订单可实现时须立即实现（比如有人取消订单，那么候补队列里的订单要立马跟上）





# 题目三：基站维修

通信基站维修，希望用最短单位时间从基站`A`到达基站`B`，且基站可能不只一个。如下：

```C++
map = ['#*...A', 'B***.#', '..A..*']

// 其实就是下面这个地图
//
//   '# * . . . A'
//   'B * * * . #'
//   '. . A . . *'
//    
// 符号含义：
// `#`是地铁站（从一个`#`到另一个`#`只需要`1`个单位时间）
// `*`是路障，走不了
// `.`是路，走一步1单位时间，只能上下左右走
// `A`、`B`是基站，返回所有`A->B`最短的时间即可，无法到达返回 -1
```

